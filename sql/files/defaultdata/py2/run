#!/bin/sh

# Python2 compile wrapper-script for 'compile.sh'.
# See that script for syntax and more info.
#
# This script does not actually "compile" the source, but writes a
# shell script that will function as the executable: when called, it
# will execute the source with the correct interpreter syntax, thus
# allowing this interpreted source to be used transparantly as if it
# was compiled to a standalone binary.
#
# NOTICE: when this compiler script is used with USE_CHROOT on, the
# chroot requires python to be installed

DEST="$1" ; shift
MEMLIMIT="$1" ; shift
MAINSOURCE="$1"

# Filter out files without .py extension from the list of source
# files. Note that POSIX shell does *not* support arrays, so we store
# them in a single variable that has to be used unquoted. We don't
# need to quote the files since they can only contain "nice" characters.
SOURCES=''
while [ $# -gt 0 ]; do
	if [ "x${1%.py}" != "x$1" ]; then
		SOURCES="$SOURCES $1"
	fi
	shift
done

# Check syntax
python2 -m py_compile $SOURCES
EXITCODE=$?
[ "$EXITCODE" -ne 0 ] && exit $EXITCODE
rm -f -- *.pyc

# Write executing script:
cat > "$DEST" <<EOF
#!/bin/sh
# Generated shell-script to execute python interpreter on source.

# Detect dirname and change dir to prevent class not found errors.
if [ "\${0%/*}" != "\$0" ]; then
	cd "\${0%/*}"
fi

# set non-existing HOME variable to make python happy
export HOME=/does/not/exist

exec pypy "$MAINSOURCE" "\$@"
EOF

chmod a+x "$DEST"

exit 0
